# JPA in Web Development

## Object-Relational Mapping

Object-Relational Mapping (**ORM**) consists of techniques that allow relating values in effect in the system classes. Thus, object-relational mapping provides communication between the application and the database. This communication consists of translating data from the object-oriented programming (OOP) language to the relational database format and vice versa. Through mapping, you no longer need to worry about schemas and SQL commands. This task will be automated for you, so that the programmer only has to worry about working with an object-oriented structure without worrying about database commands.

### ORM in Java: JPA

JPA (**Java Persistence API**) is a **Java** language specification that provides an interface for communication between **ORM** and the data in the database. Thus, by using **JPA**, you can perform object-relational mapping, providing data persistence. Based on this concept, the structure of classes, attributes, and class values will be mapped to **tables**, **columns**, and **records** in the database, respectively.

### Entity Manager

It carries the integration of **JPA** with **Hibernate** (Editora) and the data query and persistence manager. Through the **EntityManager**, you will be able to include, change, exclude, and query records in the database. You will see below some examples of how the **EntityManager** can be used to manipulate data.

In the code snippet, we have the way of defining an **entity bean**, where the object is generated by calling the **`createEntityManagerFactory()`** method of the **`Persistence`** class. The **`createEntityManager()`** method of the **`EntityManagerFactory`** generates the **`EntityManager`** object that will be used to manipulate data.

```java
public class Principal {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.
            createEntityManagerFactory("topicos");
        EntityManager em = emf.createEntityManager();
        em.getTransaction().begin();
        em.close();
        emf.close();
    }
}
```

In the following code snippet, we have an example of the **`Produto`** class, with **`setter`** and **`getter`** commands and part of the **`EntityManager`** methods for performing the inclusion, change, and exclusion of data in the database, which will be presented in the next sections.

```java
public class Produto {
    private int id;
    private String nome;
    private String descricao;
    private double preco;

    // Métodos setter e getter

    @Override
    public String toString() {
        return "Produto [id=" + id + ", nome=" + nome + ", descricao=" + descricao +
            ", preco=" + preco + "]";
    }
}
```

### Hibernate

To perform the mapping, the **JPA** standard is the interface, which requires an implementation to function. **Hibernate** is one of the most widely used *frameworks* for **JPA** implementation. It is an open-source persistence *framework* that provides data management and persistence through integration with the **JPA** interface.

For **Hibernate**, annotations are just common classes, without business methods, also known as **Plain Old Java Objects** (**POJO**). **POJO** objects are representations of database tables, where columns and data, i.e., object-relational mapping, provide data persistence.

```java
@Entity
@Table(name = "PRODUTO")
public class Produto {
    @Id
    @Column(name = "ID")
    private int id;
    @Column(name = "NOME")
    private String nome;
    @Column(name = "DESCRICAO")
    private String descricao;
    @Column(name = "PRECO")
    private double preco;

    // Métodos setter e getter
}
```

-----

## Java Persistence API

For you to be able to use **ORM** in **Java**, you need to use **JPA**. The **Java Persistence API** is a **Java** language specification that provides an interface for communication between **ORM** and the data in the database. **JPA** allows data persistence and querying in **Java SE** and **Java EE** environments. As it is only a specification, to function, **JPA** needs an implementation, which can be **Hibernate** or **EclipseLink**. The persistence data configuration must be done through an XML file, generally configured through **JPA**.

With the use of **JPA**, you no longer need to worry about working directly with tables, columns, and **SQL**. All of this will be generated automatically by the **JPA** **ORM**. You will also see how **JPA** provides data persistence and querying in **Java** applications.

### Using the `@Entity` annotation of JPA

To define a **JPA** entity, we must use a class without business methods, also known as **Plain Old Java Object** (**POJO**). **POJO** objects are representations of database tables, where columns and data, i.e., object-relational mapping, provide data persistence.

```java
@Entity
@Table(name = "PRODUTO")
public class Produto implements Serializable {
    @Id
    @Column(name = "ID")
    private int id;
    @Column(name = "NOME")
    private String nome;
    @Column(name = "DESCRICAO")
    private String descricao;
    @Column(name = "PRECO")
    private double preco;

    // Métodos setter e getter
}
```

The **`@Entity`** annotation defines the **`Produto`** class as an entity for **JPA**, while **`@Table`** specifies the database table. Attributes are annotated with **`@Id`** for the primary key field and **`@Column`** for the columns. The **`Produto`** class implements **`Serializable`**, so that the object can be serialized. We will see below, in more detail, the main annotations of a **JPA** managed entity, for object-relational mapping.

#### Main persistence annotations for JPA entities:

  * **`@Entity`**: marks the class as an entity for **JPA**.
  * **`@Table`**: specifies the table that represents the entity in the database.
  * **`@Id`**: specifies the attribute for the table's primary key.
  * **`@Column`**: maps the attribute to the table's columns.
  * **`@GeneratedValue`**: specifies the type of value generation for an attribute (like **`AUTO`** for automatic increment).
  * **`@Basic`**: specifies that an attribute is a field of the entity.
  * **`@Transient`**: specifies that an attribute is not a field of the entity.
  * **`@OneToOne`**: maps a one-to-one relationship.
  * **`@OneToMany`**: maps a one-to-many relationship.
  * **`@ManyToOne`**: maps a many-to-one relationship.
  * **`@ManyToMany`**: maps a many-to-many relationship.
  * **`@Embedded`**: maps the class to be embedded in another entity.
  * **`@EmbeddedId`**: maps the class as an embedded primary key.
  * **`@JoinColumn`**: specifies the key relationship rule.
  * **`@OrderBy`**: specifies the query order.

**JPA** entities must contain an empty constructor and an attribute based on the primary key, such as an **`int`** attribute for the **ID**, which will be the primary key. Furthermore, the class must implement the **`Serializable`** interface, so that the class can be serialized.

The persistence annotation of the **`@GeneratedValue`** attribute returns the creation mode used in **JPA** processes. The creation types can be **`AUTO`**, **`IDENTITY`**, **`SEQUENCE`**, and **`TABLE`**. By default, the type is **`AUTO`** for entity value generation.

The **`persistence.xml`** file is used to configure the **JPA** persistence unit, defining the entities to be persisted and the **ORM** properties (such as **Hibernate** or **EclipseLink**). The properties can include elements such as the **JDBC** (**Java Database Connectivity**) *driver* class or connection rules, such as the database **URL**, username, and password.

```xml
<?xml version="1.0" encoding="UTF-8"?>
<persistence version="2.0"
    xmlns="http://java.sun.com/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://java.sun.com/xml/ns/persistence http://java.sun.com/xml/ns/persistence/persistence_2_0.xsd">
    <persistence-unit name="topicos" transaction-type="RESOURCE_LOCAL">
        <provider>org.eclipse.persistence.jpa.PersistenceProvider</provider>
        <class>produto.Produto</class>
        <properties>
            <property name="javax.persistence.jdbc.driver" value="org.apache.derby.jdbc.ClientDriver"/>
            <property name="javax.persistence.jdbc.url" value="jdbc:derby://localhost:1527/dbproduto"/>
            <property name="javax.persistence.jdbc.user" value="app"/>
            <property name="javax.persistence.jdbc.password" value="app"/>
        </properties>
    </persistence-unit>
</persistence>
```

The referenced persistence unit is the name of the **persistence unit** (**`persistence-unit`**) with the value **`topicos`**. The transaction type is **`RESOURCE_LOCAL`**, so that **JPA** can integrate with **JDBC** and the **Java Transactions API** (**JTA**).

Transactional control can occur from its own *driver*, for use in the **JSE** (**Java Standard Edition**) interface or through integration with **JTA** (**Java Transactions API**).

The types are:

| Type | Description |
| :--- | :--- |
| **`RESOURCE_LOCAL`** | Uses the **JPA** transaction manager. Used for integration with **JDBC** and **Java Transactions API** (**JTA**). |
| **`JTA`** | Uses the application server transaction manager. Used for integration with **JTA** in **Java EE** (**Java Enterprise Edition**) environments. |

Next, we define the persistence *provider* in the **`<provider>`** element. The **`<class>`** element defines the entity classes and the connection properties are defined in the **`<properties>`** group.

-----

## Data Query and Manipulation

With the use of **EntityManager**, you will be able to query and manipulate data using **insertion**, **modification**, **deletion**, and **query** commands.

This way, you will have the mapping between the application and the database using **JPA** technology and the **Hibernate** or **EclipseLink** implementation. You will see below how to manipulate the application data.

### Data Query

To query data in the database, you need to obtain the **EntityManager** instance through the **`EntityManagerFactory`** and use **JPQL** (**Java Persistence Query Language**), an object-oriented query language based on the **SQL** (Structured Query Language) structure. You will see below how to use **JPQL** to query data in the database.

#### Step 1

The first step is obtaining the **EntityManagerFactory**, using the name of the persistence unit (in the example, **`topicos`**) defined in **`persistence.xml`**. Then, obtain the **EntityManager** to handle query operations.

```java
EntityManagerFactory emf = Persistence.createEntityManagerFactory("topicos");
EntityManager em = emf.createEntityManager();
```

#### Step 2

Define the query using **JPQL**, which must be based on the class attributes and the class name. The query **must not** be based on the table name but on the class name.

```java
Query query = em.createQuery("SELECT p FROM Produto p");
```

#### Step 3

Finally, execute the query and obtain the results in a **`List`** in **Java**. In practical terms, the **JPQL** query is translated by the **ORM** (like **Hibernate** or **EclipseLink**) into a native **SQL** query, which is executed in the database.

```java
List<Produto> lista = query.getResultList();
for (Produto produto : lista) {
    System.out.println(produto);
}
```

> **Attention:**
>
> You need to use **JPQL** to perform the query, which will be converted to **SQL** by **JPA**. If you use an **SQL** command directly in **`em.createQuery()`**, **JPA** will not perform the automatic conversion, using only the native **SQL** command.

### Data Insertion

To insert, you need to create an instance of **`Produto`** and add the object to the database.

```java
Produto p1 = new Produto(1, "TV", "TV de LED", 700.0);
em.getTransaction().begin();
em.persist(p1);
em.getTransaction().commit();
```

Inserting data, as it generates data, is a transaction to the database. However, when data manipulation is completed, the transaction must be finalized, by calling the method **`em.getTransaction().commit()`**.

### Data Deletion

To delete a record, we must use the **`remove()`** method to retrieve and perform the deletion. The deletion, being a change in the database, must occur between **`em.getTransaction().begin()`** and **`em.getTransaction().commit()`**.

```java
Produto p = em.find(Produto.class, 1);
em.getTransaction().begin();
em.remove(p);
em.getTransaction().commit();
```

We can observe that the classes **`Find`**, **`persist`**, **`merge`**, and **`remove`** correspond, respectively, to the **`SELECT`**, **`INSERT`**, **`UPDATE`**, and **`DELETE`** commands of **SQL**.

-----

## Application Execution

To execute the application, we will add the **Derby** *driver* and the **EclipseLink** *framework* to the project. To add the libraries, right-click on the project name and click on **Build Path -\> Configure Build Path...** and add the **EclipseLink.jar** libraries and the **Derby** *driver* in the **Libraries** tab.

### Adding the JDBC library and the EclipseLink framework

The libraries to be added are:

  * **`EclipseLink.jar`**
  * **`derbyclient.jar`** (or **`derby.jar`** if using embedded mode)

### Configuring the Derby driver

Right-click on the project, and click on **Properties -\> Java Build Path** and add the **Derby** *driver* in the **Libraries** tab.

### Defining the Derby database connection

To define the database connection, click on **Window -\> Show View -\> Other...** and select the **Data Source Explorer** option. Then, click on **Database Connections** and click on **New**.

### Application Execution Result

The execution of the application will generate the **`PRODUTO`** table in the database and insert the **`Produto`** record into it.

-----

## Manipulating Data with NamedQueries

As we have already seen, it is extremely necessary to establish communication between the application and the database. Normally, we need to perform some parameterized query, which includes receiving the query parameters directly in the application and passing them to the database.

In this video, you will see in practice how to use parameters in **NamedQueries** to retrieve table records.

### Practice Guide

We will take one more step, proposing the following challenge to you: modify the program presented earlier, so that the **`Principal`** class uses the **code** to select a specific product, through the use of **NamedQueries**.

For this, you must:

  * Use an annotation to create a **NamedQuery** in the **`Produto`** class.
  * Change the **NamedQuery** used in **`Principal`**.
  * Test the result of the practice.

**Expected result of this practice: `Class "Modelo.Produto"`.**

### `Produto` Class

```java
@Entity
@Table(name = "PRODUTO")
@NamedQueries({
    @NamedQuery(name = "Produto.findAll", query = "SELECT p FROM Produto p"),
    @NamedQuery(name = "Produto.findById", query = "SELECT p FROM Produto p WHERE p.id = :id"),
    @NamedQuery(name = "Produto.findByName", query = "SELECT p FROM Produto p WHERE p.nome LIKE :nome"),
    @NamedQuery(name = "Produto.findByPrice", query = "SELECT p FROM Produto p WHERE p.preco BETWEEN :precoMin AND :precoMax")
})
public class Produto implements Serializable {
    // ... attributes, constructor, getters and setters ...
}
```

### `Principal` Class

```java
public class Principal {
    public static void main(String[] args) {
        EntityManagerFactory emf = Persistence.
            createEntityManagerFactory("topicos");
        EntityManager em = emf.createEntityManager();

        // Query using NamedQuery with parameter
        Query query = em.createNamedQuery("Produto.findById");
        query.setParameter("id", 1); // Assuming you want to search for the product with id=1

        Produto produto = (Produto) query.getSingleResult();

        if (produto != null) {
            System.out.println("Produto encontrado: " + produto.toString());
        } else {
            System.out.println("Produto não encontrado.");
        }

        em.close();
        emf.close();
    }
}
```